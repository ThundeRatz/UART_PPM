#include <avr/io.h>
#include <util/delay.h>
#include <SoftwareSerial.h>

#define TOP_PPM 250 // at√© 255
#define MID_PPM 50  // top/2
#define MIN_PPM 0

#define PPML OCR1A
#define PPMR OCR1B

#define PPM_DELAY_US 200

#define reset_timeout() (timeout = millis())
#define get_timeout()   (millis() - timeout)

// SoftwareSerial myserial(2, 7);

int led = 8;
uint8_t auton = 0;
int vel_esq = 0, vel_dir = 0;

uint32_t timeout = 0;
uint16_t fail = 0;

void setup() {
    Serial.begin(9600);

    // myserial.begin(9600);
    

    // TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11); // Clear OCR1A/B on compare match, clear at top | Fast PWM mode
    // TCCR1B = (1 << WGM13)  | (1 << WGM12)  | (1 << CS11);  // Preescaler at clk(I/O)/8.
    // OCR1B  = 3000;
    // OCR1A  = 3000;
    // ICR1   = 40000;

    // DDRD &= ~(1 << PD0);
    // DDRB |=  (1 << PB5) | (1 << PB6);

    // EICRA = (1 << ISC00);
    // EIMSK = (1 << INT0);

    pinMode(led, OUTPUT);
}

void loop() {
        // Serial.write(75);

    if (auton >= 220 && Serial.available()) {
        Serial.write(Serial.read());
        // myserial.write(myserial.read());
        // Serial.write(6);
        // myserial.write(myserial.read());
        // parse_speed();
        // fail = 0;
        digitalWrite(led, LOW);
    } else {
        digitalWrite(led, HIGH);
    //     // fail++;
    }
    

    delay(300);

    // if (fail > 1000) {
    //     fail = 1001;
    //     vel_esq = vel_dir = 0;
    //     ppm_send(30, 0);
    // } else {
    //     ppm_send(vel_esq, vel_dir);
    // }
}

// ISR(INT0_vect) {
//     // Borda de subida
//     if (PIND & (1 << PD0)) {
//         TCNT0 = 0;
//         TCCR0B = (1 << CS01) | (1 << CS00);
//         return;
//     }
//     // Borda de descida

//     TCCR0B = 0;
//     auton = TCNT0;
//     // Serial.println(auton);
//     // Serial.println(auton);
    
// }

// uint8_t packet_buffer[8] = { 0 };

// uint8_t parse_speed() {
//     int temp;

//     temp = Serial.read();
//     // if (!(temp == 0xFF))
//     //     return 255;

//     packet_buffer[0] = temp;

//     // 6 bytes: inicio, dir_esq, vel_esq, dir_dir, vel_dir, fim
//     for (int i = 1; i <= 5; i++) {
//         reset_timeout();
//         // while ((temp = myserial.read()) == -1) {
//         //     if (get_timeout() >= 10)
//         //     return 254;
//         // }

//         packet_buffer[i] = temp;
//     }

//     // if (packet_buffer[5] != 0xFE || (packet_buffer[1] > 1) || (packet_buffer[3] > 1))
//     //     return 255;

//     vel_esq = packet_buffer[1] == 0 ? (int)(packet_buffer[2]) : -(int)(packet_buffer[2]);
//     vel_dir = packet_buffer[3] == 0 ? (int)(packet_buffer[4]) : -(int)(packet_buffer[4]);

//     Serial.write(packet_buffer, 6);
//     return 1;
// }

// void ppm_send(int vel_esq, int vel_dir) {
// 	vel_esq = constrain(vel_esq, -TOP_PPM, TOP_PPM);
// 	vel_dir = constrain(vel_dir, -TOP_PPM, TOP_PPM);

// 	uint16_t vL = map(vel_esq, -TOP_PPM, TOP_PPM, 2000, 4000);
// 	uint16_t vR = map(vel_dir, -TOP_PPM, TOP_PPM, 2000, 4000);

// 	vL = constrain(vL, 2000, 4000);
// 	vR = constrain(vR, 2000, 4000);

// 	while (PPML != vL || PPMR != vR) {
// 		if (PPML > vL)
// 			PPML--;

// 		else if (PPML < vL)
// 			PPML++;

// 		if (PPMR > vR)
// 			PPMR--;

// 		else if (PPMR < vR)
// 			PPMR++;

// 		_delay_us(PPM_DELAY_US);
// 	}
// }
